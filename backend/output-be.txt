{
  "name": "backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "nodemon src/app.js"
  },
  "dependencies": {
    "async": "^3.2.1",
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "dotenv": "^10.0.0",
    "express": "^4.17.1",
    "mariadb": "^2.5.4",
    "mssql": "^7.2.1",
    "pg": "^8.6.0",
    "spatialite": "^0.1.0",
    "sqlite3": "^5.0.2",
    "tedious": "^13.1.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.2"
  }
}
{
    "tabWidth": 2,
    "singleQuote": true,
    "printWidth": 120,
    "trailingComma": "es5",
    "prettier.tabWidth": 2,
    "prettier.singleQuote": true,
    "prettier.printWidth": 120,
    "prettier.trailingComma": "es5"
  }
  const { query, getActiveDbConnection } = require('../database/builder');

function getParsedTableName(table) {
  const { dialect } = getActiveDbConnection();
  if (dialect === 'postgres' || dialect === 'cockroach') {
    return `\"${table}\"`;
  } else if (dialect === 'mariadb' || dialect === 'mysql') {
    return `\`${table}\``;
  } else {
    throw new Error('Operação não suportada para este Banco de Dados.');
  }
}

async function mountBaseUnionQuery(allData = {}, finalQuery = false) {
  const { dialect } = getActiveDbConnection();
  if (['mariadb', 'mysql'].includes(dialect)) {
    return mountBaseUnionQueryConcatText(allData, finalQuery, dialect === 'mariadb');
  } else {
    return mountBaseUnionQueryAgg(allData, finalQuery);
  }
}

/**
 * Constrói consulta de união de todas as feições passadas considerando que a função ST_Union não possui sobrecarga de agregação.
 * @param {*} allData
 * @param {*} finalQuery
 * @returns string contendo sql resultante
 */
async function mountBaseUnionQueryConcatText(allData = {}, finalQuery = false, isMariaDb = false) {
  let topQuery = 'T.geom';
  let tablesQuery = '';
  const tables = Object.keys(allData);

  let hasGids;
  for (let idx = 0; idx < tables.length; idx++) {
    const table = tables[idx];
    const parsedTableName = getParsedTableName(table);
    hasGids = allData[table].data.length > 0;

    const innerQuery = `SELECT ST_AsText(${allData[table].geometryColumn}) as geom_t FROM ${parsedTableName} ${
      hasGids ? 'WHERE gid IN (' + allData[table].data.join(',') + ')' : ''
    }`;

    const textGeometries = (await query(innerQuery)) ?? [];

    let innerUnionQuery = '';

    textGeometries.forEach(({ geom_t }, index) => {
      if (!innerUnionQuery) {
        innerUnionQuery = `ST_GeomFromText(\'${geom_t}\')`;
      } else {
        innerUnionQuery = `ST_Union(ST_GeomFromText(\'${geom_t}\'),${innerUnionQuery})`;
      }
    });

    innerUnionQuery = `SELECT ST_AsText(${innerUnionQuery}) as geom FROM DUAL`;

    let preUnionGeometry = await query(innerUnionQuery);

    if (preUnionGeometry.length > 0) {
      preUnionGeometry = preUnionGeometry[0].geom;
    } else {
      throw new Error('Erro ao construir as consultas bases de União!');
    }

    if (idx === 0) {
      tablesQuery = `ST_GeomFromText(\'${preUnionGeometry}\')`;
    } else {
      tablesQuery = `ST_Union(ST_GeomFromText(\'${preUnionGeometry}\'),${tablesQuery})`;
    }
  }

  tablesQuery = 'FROM ( SELECT ' + tablesQuery + ' as geom FROM DUAL';

  topQuery = `SELECT ${finalQuery ? 'ST_AsGeoJSON(' : ''} ${topQuery}`;

  topQuery += `${finalQuery ? ')' : ''} as ${finalQuery ? 'geometry' : 'geom'} `;

  return topQuery + tablesQuery + ') T';
}

// /**
//  * Constrói consulta de união de todas as feições passadas considerando que a função ST_Union não possui sobrecarga de agregação.
//  * @param {*} allData
//  * @param {*} finalQuery
//  * @returns string contendo sql resultante
//  */
// function mountBaseUnionQueryConcatText(allData = {}, finalQuery = false, isMariaDb = false) {
//   let topQuery = 'T.geom';
//   let tablesQuery = 'FROM (';
//   const tables = Object.keys(allData);

//   const getGeoTextConcat = (colName) => {
//     const innerElement = `concat('GEOMETRYCOLLECTION (', GROUP_CONCAT(ST_AsText(${colName})), ')')`;
//     return (
//       `ST_Union(ST_GeomFromText(${innerElement}), ` +
//       `ST_GeomFromText(${isMariaDb ? innerElement : 'GEOMETRYCOLLECTION EMPTY'}))`
//     );
//   };

//   let hasGids;
//   tables.forEach((table, idx) => {
//     const parsedTableName = getParsedTableName(table);
//     hasGids = allData[table].data.length > 0;

//     tablesQuery += ` (SELECT ${getGeoTextConcat(allData[table].geometryColumn)} as geom FROM ${parsedTableName} ${
//       hasGids ? 'WHERE gid IN (' + allData[table].data.join(',') + ')' : ''
//     }) ${idx + 1 < tables.length ? 'UNION' : ''} `;
//   });

//   topQuery = `SELECT ${finalQuery ? 'ST_AsGeoJSON(' : ''} ${topQuery}`;

//   topQuery += `${finalQuery ? ')' : ''} as ${finalQuery ? 'geometry' : 'geom'} `;

//   console.log(topQuery + tablesQuery + ') T');
//   return topQuery + tablesQuery + ') T';
// }

/**
 * Constrói consulta de união de todas as feições passadas utilizando uma função ST_Union de agregação.
 * @param {*} allData
 * @param {*} finalQuery
 * @returns string contendo sql resultante
 */
function mountBaseUnionQueryAgg(allData = {}, finalQuery = false) {
  let topQuery = '';
  let tablesQuery = 'FROM ';
  const tables = Object.keys(allData);

  let hasGids;
  tables.forEach((table, idx) => {
    const parsedTableName = getParsedTableName(table);
    hasGids = allData[table].data.length > 0;

    topQuery += `t${idx}.geom${idx + 1 < tables.length ? ',' : ''} `;
    tablesQuery += ` (SELECT ${hasGids ? 'ST_Union(' : ''}${allData[table].geometryColumn}${
      hasGids ? ')' : ''
    } as geom FROM ${parsedTableName} ${
      hasGids ? 'WHERE gid IN (' + allData[table].data.join(',') + ')' : ''
    }) t${idx}${idx + 1 < tables.length ? ',' : ''} `;
  });

  topQuery = `SELECT ${finalQuery ? 'ST_AsGeoJSON(' : ''}${hasGids ? 'ST_Union(' : ''} ${topQuery}`;

  topQuery += `${finalQuery ? ')' : ''}${hasGids ? ')' : ''} as ${finalQuery ? 'geometry' : 'geom'} `;

  return topQuery + tablesQuery;
}

async function mountBySpatialFunction(dataA, dataB, func) {
  let topQuery = `SELECT ST_AsGeoJSON(${func}(A.geom, B.geom)) as geometry FROM `;

  const queryA = await mountBaseUnionQuery(dataA);
  const queryB = await mountBaseUnionQuery(dataB);

  return `${topQuery} (${queryA}) A, (${queryB}) B`;
}

module.exports = {
  async executeSql(sql) {
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getUnion(data = {}) {
    const sql = await mountBaseUnionQuery(data, true);
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getFromGeoFunction(dataA = {}, dataB = {}, func) {
    const sql = await mountBySpatialFunction(dataA, dataB, func);
    const data = await query(sql);
    return { data, query: sql };
  },

  async getFromBooleanFunction(dataA = {}, dataB = {}, func, invertCondition) {
    let topQuery = 'SELECT ST_AsGeoJSON(B.geom) as geometry FROM ';

    const queryA = await mountBaseUnionQuery(dataA);
    const queryB = await mountBaseUnionQuery(dataB);

    const sql = `${topQuery} (${queryA}) A, (${queryB}) B WHERE ${func}${
      invertCondition ? '(B.geom, A.geom)' : '(A.geom, B.geom)'
    }`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getArea(data = {}) {
    const { dialect } = getActiveDbConnection();
    const unionSql = await mountBaseUnionQuery(data);
    const sql = `SELECT ST_Area(A.geom${['mysql', 'mariadb'].includes(dialect) ? '' : ', TRUE'})${
      ['postgres', 'cockroach'].includes(dialect) ? '/(1000*1000)' : ''
    } as area_km2 FROM (${unionSql}) A`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getDistance(dataA = {}, dataB = {}) {
    let topQuery = 'SELECT ST_Distance(A.geom, B.geom, TRUE)/1000 as dist_km FROM ';

    const queryA = await mountBaseUnionQuery(dataA);
    const queryB = await mountBaseUnionQuery(dataB);

    const sql = `${topQuery} (${queryA}) A, (${queryB}) B`;
    const data = await query(sql);
    return { data, query: sql };
  },

  async getLength(data = {}) {
    let topQuery = 'SELECT ST_Length(A.geom, TRUE)/1000 as len_km FROM ';

    const queryA = await mountBaseUnionQuery(data);

    const sql = `${topQuery} (${queryA}) A`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getPerimeter(data = {}) {
    let topQuery = 'SELECT ST_Perimeter(A.geom, TRUE)/1000 as perim_km FROM ';

    const queryA = await mountBaseUnionQuery(data);

    const sql = `${topQuery} (${queryA}) A`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getBuffer(data = {}, radius) {
    let topQuery = `SELECT ST_AsGeoJSON(ST_Buffer(A.geom, ${radius})) as geometry FROM `;

    const queryA = await mountBaseUnionQuery(data);

    const sql = `${topQuery} (${queryA}) A`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async getCentroid(data = {}) {
    let topQuery = `SELECT ST_AsGeoJSON(ST_Centroid(A.geom)) as geometry FROM `;

    const queryA = await mountBaseUnionQuery(data);

    const sql = `${topQuery} (${queryA}) A`;
    const result = await query(sql);
    return { data: result, query: sql };
  },

  async saveQueryToTable(tableName, sql) {
    if (!tableName) {
      throw 'É necessário definir o nome da tabela de destino!';
    }

    await query(`CREATE TABLE ${tableName} (
      GID SERIAL PRIMARY KEY,
      GEOM GEOMETRY
    )`);

    if (sql.includes('ST_AsGeoJSON')) {
      sql = sql.replace('ST_AsGeoJSON', '');
    }

    await query(`INSERT INTO ${tableName} (geom) ${sql}`);
  },
};
const { refreshDatabaseConnections } = require('../database/builder');
const { execute, query, queryOne } = require('../database/sqlite');
module.exports = {
  async save({ type, host, port, database, user, password, dialect, active }) {
    const configuration = await this.get(type, dialect, host, port);
    if (configuration) {
      await execute('DELETE FROM database WHERE type = ? AND dialect = ? AND host = ? AND port = ?;', [type, client]);
    }
    const result = await execute(
      'INSERT INTO database(type, host, port, database, user, password, dialect, active) VALUES (?,?,?,?,?,?,?,?);',
      [type, host, port, database, user, password, dialect, active]
    );
    refreshDatabaseConnections();
    return result;
  },
  getAll() {
    return query('SELECT * FROM database');
  },
  get(type, dialect, host, port) {
    return queryOne('SELECT * FROM database WHERE type = ? AND dialect = ? AND host = ? AND port = ?', [
      type,
      dialect,
      host,
      port,
    ]);
  },
  async delete(type, dialect, host, port, user, database) {
    const result = await execute(
      'DELETE FROM database WHERE type = ? AND dialect = ? AND host = ? AND port = ? AND user = ? AND database = ?',
      [type, dialect, host, port, user, database]
    );
    refreshDatabaseConnections();
    return result;
  },
  async setActiveDatabase(dialect, host, port, user, database) {
    await execute("UPDATE DATABASE SET ACTIVE='false'");
    await execute(
      "UPDATE DATABASE SET ACTIVE='true' WHERE DIALECT = ? AND HOST = ? AND PORT = ? AND USER = ? AND DATABASE = ?",
      [dialect, host, port, user, database]
    );
    refreshDatabaseConnections();
  },
};
const { execute, query, queryOne } = require('../database/sqlite');

const atts = ['type', 'host', 'database', 'username', 'password', 'port', 'dialect'];

const buildWhereClause = (params = {}) => {
  let whereClause = '';
  const paramValues = [];
  const keys = Object.keys(params);

  keys.forEach((paramKey) => {
    if (atts.includes(paramKey) && params[paramKey]) {
      whereClause += `${whereClause ? ' AND ' : ''} ${paramKey} = ? `;
      paramValues.push(params[paramKey]);
    }
  });

  return { paramValues, whereClause };
};

module.exports = {
  async save(type, host, database, username, password, port, dialect) {
    return execute(
      'INSERT INTO db_sequilize(type, host, database, username, password, port, dialect) VALUES (?,?,?,?,?,?,?);',
      [type, host, database, username, password, port, dialect]
    );
  },
  getAll(params = {}) {
    const { paramValues, whereClause } = buildWhereClause(params);
    if (whereClause) {
      return query(`SELECT * FROM db_sequilize WHERE ${whereClause}`, paramValues);
    } else {
      return query(`SELECT * FROM db_sequilize`);
    }
  },
  get(params = {}) {
    if (!Object.keys(params).length > 0) {
      throw 'Params must be passed!';
    }
    const { paramValues, whereClause } = buildWhereClause(params);
    return queryOne(`SELECT * FROM db_sequilize WHERE ${whereClause} `, paramValues);
  },
  delete(type, host, port, database) {
    return execute('DELETE FROM db_sequilize WHERE type = ? AND host = ? AND port = ? AND database = ?', [
      type,
      host,
      port,
      database,
    ]);
  },
};
const { query, getActiveDbConnection } = require('../database/builder');

module.exports = {
  async getTablesNames() {
    const result = await query(getTableNameQuery());
    return result;
  },

  async getColumns(table) {
    return await query(getColumnsMetadata(table));
  },

  async getGeometryColmuns(table) {
    return await query(getColumnsMetadata(table, true));
  },
};

const getTableNameQuery = () => {
  const dbParams = getActiveDbConnection();
  let resultQuery = '';
  if (dbParams.dialect === 'postgres' || dbParams.dialect === 'cockroach') {
    resultQuery = `select table_name as name from information_schema.columns where udt_name = 'geometry' and is_updatable = 'YES' and table_catalog = '${dbParams.database}' and table_schema != 'tiger' and table_schema != 'tiger_data' and table_schema != 'topology'`;
  } else if (dbParams.dialect === 'mariadb' || dbParams.dialect === 'mysql') {
    resultQuery =
      'select col.table_name as name ' +
      'from information_schema.columns col' +
      ' join information_schema.tables tab' +
      ' on col.table_schema = tab.table_schema' +
      ' and col.table_name = tab.table_name' +
      " and table_type = 'BASE TABLE'" +
      " where col.data_type in ('geometry', 'point', 'linestring', 'polygon'," +
      " 'multipoint', 'multilinestring', 'multipolygon'," +
      " 'geometrycollection')" +
      " and col.table_schema not in ('information_schema', 'sys'," +
      " 'performance_schema', 'mysql')" +
      ` and col.table_schema = '${dbParams.database}'` +
      ' order by col.table_schema,' +
      ' col.table_name';
  } else if (dbParams.dialect === 'mssql') {
    resultQuery = `select table_name as name from information_schema.columns where DATA_TYPE = 'geometry' AND table_schema = '${dbParams.database}'`;
  } else if (dbParams.dialect === 'sqlite') {
    resultQuery = `SELECT m.name as name FROM sqlite_master AS m, pragma_table_info(m.name) AS p WHERE UPPER(p.type) in ('POINT', 'LINESTRING', 'POLYGON', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON', 'GEOMETRYCOLLECTION')`;
  } else {
    throw new Error('Operação não suportada para este Banco de Dados.');
  }
  return resultQuery;
};

const getColumnsMetadata = (table, spatialOnly = false) => {
  const dbParams = getActiveDbConnection();
  let resultQuery = '';
  if (dbParams.dialect === 'postgres' || dbParams.dialect === 'cockroach') {
    resultQuery = `SELECT column_name AS ${
      spatialOnly ? 'geom_' : 'norm_'
    }column FROM information_schema.columns WHERE table_name = '${table}' and table_catalog = '${
      dbParams.database
    }' AND udt_name ${spatialOnly ? '=' : '!='} 'geometry'`;
  } else if (dbParams.dialect === 'mariadb' || dbParams.dialect === 'mysql') {
    resultQuery =
      `select COLUMN_NAME as ${spatialOnly ? 'geom_' : 'norm_'}column from information_schema.columns ` +
      ` where TABLE_NAME = '${table}' ` +
      ` and data_type ${spatialOnly ? '' : 'not'} in ('geometry', 'point', 'linestring', 'polygon', ` +
      " 'multipoint', 'multilinestring', 'multipolygon', " +
      " 'geometrycollection')";
  } else if (dbParams.dialect === 'mssql') {
    resultQuery = `SELECT COLUMN_NAME AS ${
      spatialOnly ? 'geom_' : 'norm_'
    }column from information_schema.columns where TABLE_NAME = '${table}' AND DATA_TYPE ${
      spatialOnly ? '=' : '!='
    } 'geometry' AND table_schema = '${dbParams.database}'`;
  } else {
    throw new Error('Operação não suportada para este Banco de Dados.');
  }
  return resultQuery;
};
const { query, getActiveDbConnection } = require('../database/builder');

module.exports = {
  async getLayer(table, columns, geometryColumn) {
    const cols = await columns
      .map((c) => {
        return c.norm_column;
      })
      .join(',');
    return query(buildLayerQuery(cols, geometryColumn, table));
  },
};

const buildLayerQuery = (cols = [], geometryColumn, table) => {
  const dbParams = getActiveDbConnection();
  let resultQuery = '';
  if (dbParams.dialect === 'postgres' || dbParams.dialect === 'cockroach') {
    resultQuery = `SELECT  ${
      cols.length > 0 ? cols + ',' : ''
    } ST_AsGeoJSON(t.${geometryColumn}) AS geometry  FROM \"${table}\" t`;
  } else if (dbParams.dialect === 'mariadb' || dbParams.dialect === 'mysql') {
    resultQuery = `SELECT  ${
      cols.length > 0 ? cols + ',' : ''
    } ST_AsGeoJSON(t.${geometryColumn}) AS geometry  FROM \`${table}\` t`;
  } else {
    throw new Error('Banco de Dados não suportado.');
  }
  return resultQuery;
};
const { execute, query, queryOne } = require('../database/sqlite');
module.exports = {
  async save(table, json) {
    const savedLayer = await this.get(table);
    if (savedLayer) {
      await execute('DELETE FROM saved_layers WHERE table_name = ?;', [table]);
    }
    return execute('INSERT INTO saved_layers(table_name, json) VALUES (?,?);', [table, json]);
  },
  getAll() {
    return query('SELECT * FROM saved_layers');
  },
  get(table) {
    return queryOne('SELECT * FROM saved_layers WHERE table_name = ?;', [table]);
  },
  delete(table) {
    return execute('DELETE FROM saved_layers WHERE table_name = ?;', [table]);
  },
  deleteAll() {
    return execute('DELETE FROM saved_layers;');
  },
};
const repository = require('../repository/seqDatabaseRepository');

module.exports = {
  async save(request, response) {
    try {
      const { type, host, database, username, password, port, dialect } = request.body;
      await repository.save(type, host, database, username, password, port, dialect);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.log(err);
    }
  },
  async getAll(request, response) {
    try {
      // const { type } = request.query;
      const db = await repository.getAll(request.query);
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async get(request, response) {
    try {
      const { type, host, port, database } = request.query;
      const db = await repository.get({ type, host, port, database });
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async delete(request, response) {
    try {
      const { type, host, port, database } = request.body;
      await repository.delete(type, host, port, database);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.log(err);
    }
  },
};
const repository = require('../repository/databaseRepository');

module.exports = {
  async save(request, response) {
    try {
      await repository.save(request.body);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async getAll(request, response) {
    try {
      const db = await repository.getAll();
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async get(request, response) {
    try {
      const { type, dialect, host, port } = request.query;
      const db = await repository.get(type, dialect, host, port);
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async delete(request, response) {
    try {
      const { type, dialect, host, port, user, database } = request.body;
      if (!type || !dialect || !host || !port || !user || !database) {
        throw new Error('Parâmetros de remoção inválidos.');
      }
      await repository.delete(type, dialect, host, port, user, database);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async setActiveDatabase(request, response) {
    try {
      const { dialect, host, port, user, database } = request.body;
      await repository.setActiveDatabase(dialect, host, port, user, database);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
};
const repository = require('../repository/tableRepository');

module.exports = {
  async index(_, response) {
    try {
      const data = await repository.getTablesNames();
      let i = 0;
      let result = [];
      let table;
      let columns;
      let geometryColumns;
      while (i < data.length) {
        table = data[i].name;
        columns = await repository.getColumns(table);
        geometryColumns = await repository.getGeometryColmuns(table);
        result = [
          ...result,
          {
            name: table,
            columns: columns.map((t) => {
              return t.norm_column;
            }),
            geometryColumns: geometryColumns.map((col) => {
              return col.geom_column;
            }),
          },
        ];
        i += 1;
      }
      response.json(result);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
};
const repository = require('../repository/queryRepository');

const validationSql = (sql) => {
  ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'CREATE', 'ALTER'].forEach((opr) => {
    if (sql.toUpperCase().includes(opr)) {
      throw new Error('Operação não permitida.');
    }
  });
};

module.exports = {
  async spatialQuery(request, response) {
    try {
      const { first, second, operation, auxiliar } = request.body;
      let data;
      switch (operation) {
        case 'union':
          data = await repository.getUnion(first);
          break;
        case 'diff':
          data = await repository.getFromGeoFunction(first, second, 'ST_Difference');
          break;
        case 'intersection':
          data = await repository.getFromGeoFunction(first, second, 'ST_Intersection');
          break;
        case 'contains':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Contains');
          break;
        case 'crosses':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Crosses');
          break;
        case 'touches':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Touches');
          break;
        case 'within':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Within', true);
          break;
        case 'disjoint':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Disjoint');
          break;
        case 'intersects':
          data = await repository.getFromBooleanFunction(first, second, 'ST_Intersects');
          break;
        case 'area':
          data = await repository.getArea(first);
          break;
        case 'distance':
          data = await repository.getDistance(first, second);
          break;
        case 'length':
          data = await repository.getLength(first);
          break;
        case 'perimeter':
          data = await repository.getPerimeter(first);
          break;
        case 'buffer':
          data = await repository.getBuffer(first, auxiliar);
          break;
        case 'centroid':
          data = await repository.getCentroid(first);
          break;
      }
      response.status(200).json(data);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async sql(request, response) {
    try {
      const { sql } = request.body;
      validationSql(sql);
      const data = await repository.executeSql(sql);
      response.status(200).json(data);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async saveQueryIntoTable(request, response) {
    try {
      const { tableName, sql } = request.body;
      validationSql(sql);
      validationSql(tableName);
      await repository.saveQueryToTable(tableName, sql);
      response.status(200).json({});
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
};
const repository = require('../repository/layerRepository');
const tableRepository = require('../repository/tableRepository');

module.exports = {
  async index(request, response) {
    const layer = request.params.layer;
    const geometryColumn = request.params.geometryColumn;
    try {
      const columns = await tableRepository.getColumns(layer);
      const data = await repository.getLayer(layer, columns, geometryColumn);
      response.json(data);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
};
const repository = require('../repository/savedLayersRepository');

module.exports = {
  async save(request, response) {
    try {
      const { table, data } = request.body;
      const stringJson = JSON.stringify(data);
      await repository.save(table, stringJson);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.log(err);
    }
  },
  async getAll(request, response) {
    try {
      const db = await repository.getAll();
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async get(request, response) {
    try {
      const { table } = request.query;
      const db = await repository.get(table);
      response.status(200).json(db);
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.error(err);
    }
  },
  async delete(request, response) {
    try {
      const { table } = request.body;
      await repository.delete(table);
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.log(err);
    }
  },
  async deleteAll(request, response) {
    try {
      await repository.deleteAll();
      response.status(200).json();
    } catch (err) {
      response.status(500).json({ message: err.message });
      console.log(err);
    }
  },
};
require('dotenv').config();

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const { ddlUser } = require('./ddlUser');
const routes = require('./routes');
const { refreshDatabaseConnections } = require('./database/builder');

const app = express();

(async () => {
  await ddlUser();
  refreshDatabaseConnections();
})();

app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));
app.use(cors());
app.use(express.json());
app.use(process.env.API_PATH, routes);

app.listen(8000);
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const dbPath = path.resolve(__dirname, 'user.db');

const query = (query, params = []) => {
  const db = new sqlite3.Database(dbPath);
  return new Promise((resolve, reject) => {
    db.all(query, params, (err, rows) => {
      db.close();
      if (err) {
        reject(err);
      } else {
        resolve(rows);
      }
    });
  });
};

const queryOne = (query, params = []) => {
  const db = new sqlite3.Database(dbPath);
  return new Promise((resolve, reject) => {
    db.get(query, params, (err, row) => {
      db.close();
      if (err) {
        reject(err);
      } else {
        resolve(row);
      }
    });
  });
};

const execute = (query, params = [], callbackSucess = () => {}, callbackError = (err) => {}) => {
  const db = new sqlite3.Database(dbPath);
  return new Promise((resolve, reject) => {
    db.run(query, params, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
      db.close();
    });
  });
};

module.exports = { query, execute, queryOne };
const { query } = require('../database/sqlite');
const spatialite = require('spatialite');
const { Client } = require('pg');
const mariadb = require('mariadb');
require('dotenv').config();

let dbsConfiguration;
let activeConnection;

const refreshDatabaseConnections = async () => {
  dbsConfiguration = await query('SELECT * FROM database');
  activeConnection = -1;
  dbsConfiguration &&
    dbsConfiguration.length > 0 &&
    dbsConfiguration.forEach((config, idx) => {
      if (config.active && config.active === 'true') {
        activeConnection = idx;
      }
    });
};

const queryFromDb = async (queryText, ...otherParams) => {
  const { client, dialect } = await buildClient();
  if (dialect === 'sqlite') {
    return new Promise((resolve, reject) => {
      client.all(queryText, ...otherParams, (err, rows) => {
        client.close();
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  } else {
    const result = await client.query(queryText, ...otherParams);
    closeClient(client, dialect);
    return getReturnFromResult(result, dialect);
  }
};

const getReturnFromResult = (result, dialect) => {
  const propToAccess = {
    postgres: 'rows',
    mysql: 'rows',
    mariadb: 'rows',
    cockroach: 'rows',
  };

  if (['postgres', 'cockroach'].includes(dialect)) {
    return result[propToAccess[dialect]];
  } else {
    return result;
  }
};

const getActiveDbConnection = () => {
  if (dbsConfiguration !== undefined && dbsConfiguration !== null) {
    return dbsConfiguration[activeConnection];
  } else {
    throw new Error('Erro ao obter conexão ativa de banco de dados.');
  }
};

const buildClient = async (callback) => {
  const conf = getActiveDbConnection();
  if (!conf) {
    throw new Error('Configuração de banco de dados não definida.');
  }
  const { dialect } = conf;

  const connParams = {};
  ['user', 'password', 'host', 'port', 'database'].forEach((key) => {
    connParams[key] = conf[key];
  });

  let client;
  if (dialect === 'postgres') {
    client = new Client(connParams);
    client.connect();
  } else if (dialect === 'cockroach') {
    client = new Client(
      `postgres://${connParams.user}@${connParams.host}:${connParams.port}/${connParams.database}?sslmode=disable`
    );
    client.connect();
  } else if (dialect === 'mariadb' || dialect === 'mysql') {
    try {
      client = await mariadb.createConnection(connParams);
    } catch {
      throw new Error('Erro ao conectar com o banco de dados MariaDB.');
    }
    // } else if (dialect === 'mssql') {
    // client = { ...connParams, server: connParams.host, options: { trustServerCertificate: true } };
  } else if ('sqlite') {
    client = new spatialite.Database(connParams.host);
  } else {
    throw new Error('Banco de dados não suportado.');
  }
  return { client, dialect };
};

const closeClient = (client, dialect) => {
  const propToAccess = {
    postgres: 'end',
    mysql: 'end',
    mariadb: 'end',
    cockroach: 'end',
  };
  client[propToAccess[dialect]]();
};

module.exports = { refreshDatabaseConnections, query: queryFromDb, getActiveDbConnection };
const { execute, queryOne } = require('./database/sqlite');
module.exports = {
  async ddlUser() {
    await execute(
      'CREATE TABLE IF NOT EXISTS database (\
            type TEXT,\
            host TEXT,\
            port INTEGER,\
            user TEXT,\
            password TEXT,\
            database TEXT,\
            dialect TEXT,\
            active TEXT,\
            CONSTRAINT database_pk PRIMARY KEY(type, host, port, database));'
    );

    const configuration = await queryOne("SELECT * FROM database WHERE type = 'postgres' AND dialect = 'postgres'");
    if (configuration) {
      await execute("UPDATE database SET host = ?, port = ? WHERE type = 'postgres' AND dialect = 'postgres';", [
        process.env.DB_IP_ADRESS,
        process.env.DB_PORT,
      ]);
    } else {
      await execute(
        'INSERT INTO database(type, host, port, database, user, password, dialect, active) VALUES (?,?,?,?,?,?,?,?);',
        [
          'postgres',
          process.env.DB_IP_ADRESS,
          process.env.DB_PORT,
          'postgres',
          'postgres',
          'postgres', //Passar por env posteriormente
          'postgres',
          'true',
        ]
      );
    }

    await execute(
      'CREATE TABLE IF NOT EXISTS saved_layers (\
                table_name TEXT,\
                json TEXT,\
                CONSTRAINT saved_layers_pk PRIMARY KEY(table_name));'
    );
  },
};
const express = require('express');
const routes = express.Router();

const layerController = require('./controllers/layerController');
const tableController = require('./controllers/tableController');
const databaseController = require('./controllers/databaseController');
const seqDatabaseController = require('./controllers/seqDatabaseController');
const savedLayersController = require('./controllers/savedLayersController');
const queryRepository = require('./controllers/queryController');

routes.get('/layer/:layer/:geometryColumn', (req, res) => {
  return redirect(req, res, layerController.index);
});

routes.get('/tables', (req, res) => {
  return redirect(req, res, tableController.index);
});

//Rotas para armazenamento de dados do Usuário
routes.post('/database', (req, res) => {
  return redirect(req, res, databaseController.save);
});

routes.get('/database/all', (req, res) => {
  return redirect(req, res, databaseController.getAll);
});

routes.get('/database', (req, res) => {
  return redirect(req, res, databaseController.get);
});

routes.delete('/database', (req, res) => {
  return redirect(req, res, databaseController.delete);
});

routes.post('/database/set-active', (req, res) => {
  return redirect(req, res, databaseController.setActiveDatabase);
});

//Rotas para armazenamento de dados do Usuário - 2
routes.post('/db', (req, res) => {
  return redirect(req, res, seqDatabaseController.save);
});

routes.get('/db/all', (req, res) => {
  return redirect(req, res, seqDatabaseController.getAll);
});

routes.get('/db', (req, res) => {
  return redirect(req, res, seqDatabaseController.get);
});

routes.delete('/db', (req, res) => {
  return redirect(req, res, seqDatabaseController.delete);
});

//Rotas para armazenamento de Camadas do Mapa
routes.post('/persisted-layers', (req, res) => {
  return redirect(req, res, savedLayersController.save);
});

routes.get('/persisted-layers/all', (req, res) => {
  return redirect(req, res, savedLayersController.getAll);
});

routes.get('/persisted-layers', (req, res) => {
  return redirect(req, res, savedLayersController.get);
});

routes.delete('/persisted-layers', (req, res) => {
  return redirect(req, res, savedLayersController.delete);
});

routes.delete('/persisted-layers/all', (req, res) => {
  return redirect(req, res, savedLayersController.deleteAll);
});

//Rotas para consultas espaciais básicas
routes.post('/spatial-query', (req, res) => {
  return redirect(req, res, queryRepository.spatialQuery);
});

routes.post('/sql', (req, res) => {
  return redirect(req, res, queryRepository.sql);
});

routes.post('/query-to-table', (req, res) => {
  return redirect(req, res, queryRepository.saveQueryIntoTable);
});

const redirect = (req, res, route) => {
  try {
    return route(req, res);
  } catch {
    return res.status(500).json({ mensagem: 'Ocorreu um erro interno!' });
  }
};

module.exports = routes;
